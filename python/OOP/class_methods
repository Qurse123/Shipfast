## class methods and static methods

import datetime
class Employee: ## This is a class 

    num_of_emps = 0 
    raise_amt = 1.04 
    
    
    def __init__(self, first, last, pay): 
        self.first = first
        self.last = last 
        self.pay = pay 
        self.email = first + "." + last + "@company.com"
        Employee.num_of_emps +=1 

    def fullname(self): 
        return  "\n" + self.first + " " + self.last
    
    def apply_raise(self):
        self.pay = int(self.pay * Employee.raise_amt) 
        
    @classmethod
    def set_raise_amt(cls, amount): ## cls means class
        cls.raise_amt = amount
    
    @classmethod ## alternative constructor method
    def from_string(cls, emp_str):
        first, last, pay = emp_str.split('-') ## used to take strings of employess defined as first name, last name and pay and take out the individual important info so it splits the string on the hyphen
        return cls(first, last, pay) ## creates and returns a new employee object

    @staticmethod ## do not take instance or class as first argument
    def is_workday(day):
        if day.weekday() == 5 or day.weekday() == 6: ## 5 is a saturday python has a feature where days of the week are marked from 0 to 6 
            return False
        
        return True


        # we use a static method if we never use a class or self method anywhere

emp_1 = Employee("Sam", "Smith", "10")
emp_2 = Employee("Joe", "King", "20")

my_date = datetime.date(2025, 9, 13)

print(Employee.is_workday(my_date))










#Employee.set_raise_amt(1.05) # This is created becuase it already calls class (cls) so all we have to do is enter an ammount and now the class variable we created 
# where raise_amt is 1.04 has now been changed to 1.05

